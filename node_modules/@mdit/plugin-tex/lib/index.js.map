{"version":3,"file":"index.js","sources":["../src/plugin.ts"],"sourcesContent":["/**\n * Forked from https://github.com/waylonflinn/markdown-it-katex/blob/master/index.js\n */\n\nimport type { PluginWithOptions } from \"markdown-it\";\nimport type { RuleBlock } from \"markdown-it/lib/parser_block.mjs\";\nimport type { RuleInline } from \"markdown-it/lib/parser_inline.mjs\";\nimport type StateInline from \"markdown-it/lib/rules_inline/state_inline.mjs\";\n\nimport type { MarkdownItTexOptions } from \"./options.js\";\n\n/*\n * Test if potential opening or closing delimiter\n * Assumes that there is a \"$\" at state.src[pos]\n */\nconst isValidDelim = (\n  state: StateInline,\n  pos: number,\n  allowInlineWithSpace: boolean,\n): { canOpen: boolean; canClose: boolean } => {\n  const prevChar = state.src.charAt(pos - 1);\n  const nextChar = state.src.charAt(pos + 1);\n\n  return {\n    canOpen: allowInlineWithSpace || (nextChar !== \" \" && nextChar !== \"\\t\"),\n\n    /*\n     * Check non-whitespace conditions for opening and closing, and\n     * check that closing delimiter isnâ€™t followed by a number\n     */\n    canClose:\n      !/[0-9]/u.exec(nextChar) &&\n      (allowInlineWithSpace || (prevChar !== \" \" && prevChar !== \"\\t\")),\n  };\n};\n\nconst getInlineTex =\n  (allowInlineWithSpace: boolean): RuleInline =>\n  (state, silent) => {\n    if (state.src[state.pos] !== \"$\") return false;\n\n    let delimState = isValidDelim(state, state.pos, allowInlineWithSpace);\n\n    if (!delimState.canOpen) {\n      if (!silent) state.pending += \"$\";\n\n      state.pos++;\n\n      return true;\n    }\n\n    /*\n     * First check for and bypass all properly escaped delimiters\n     * This loop will assume that the first leading backtick can not\n     * be the first character in state.src, which is known since\n     * we have found an opening delimiter already.\n     */\n    const start = state.pos + 1;\n\n    let match = start;\n    let pos: number;\n\n    while ((match = state.src.indexOf(\"$\", match)) !== -1) {\n      /*\n       * Found potential $, look for escapes, pos will point to\n       * first non escape when complete\n       */\n      pos = match - 1;\n      while (state.src[pos] === \"\\\\\") pos--;\n\n      // Even number of escapes, potential closing delimiter found\n      if ((match - pos) % 2 === 1) break;\n\n      match++;\n    }\n\n    // No closing delimiter found.  Consume $ and continue.\n    if (match === -1) {\n      if (!silent) state.pending += \"$\";\n\n      state.pos = start;\n\n      return true;\n    }\n\n    // Check if we have empty content, ie: $$.  Do not parse.\n    if (match - start === 0) {\n      if (!silent) state.pending += \"$$\";\n\n      state.pos = start + 1;\n\n      return true;\n    }\n\n    // Check for valid closing delimiter\n    delimState = isValidDelim(state, match, allowInlineWithSpace);\n\n    if (!delimState.canClose) {\n      if (!silent) state.pending += \"$\";\n\n      state.pos = start;\n\n      return true;\n    }\n\n    if (!silent) {\n      const token = state.push(\"math_inline\", \"math\", 0);\n\n      token.markup = \"$\";\n      token.content = state.src.slice(start, match);\n    }\n\n    state.pos = match + 1;\n\n    return true;\n  };\n\nconst blockTex: RuleBlock = (state, start, end, silent) => {\n  let pos = state.bMarks[start] + state.tShift[start];\n  let max = state.eMarks[start];\n\n  if (pos + 2 > max) return false;\n\n  if (state.src.slice(pos, pos + 2) !== \"$$\") return false;\n\n  pos += 2;\n  let firstLine = state.src.slice(pos, max).trim();\n\n  if (silent) return true;\n\n  let found = false;\n\n  if (firstLine.endsWith(\"$$\")) {\n    // Single line expression\n    firstLine = firstLine.slice(0, -2);\n    found = true;\n  }\n\n  let current = start;\n  let lastLine = \"\";\n\n  while (!found) {\n    current++;\n    if (current >= end) break;\n\n    pos = state.bMarks[current] + state.tShift[current];\n    max = state.eMarks[current];\n\n    // non-empty line with negative indent should stop the list:\n    if (pos < max && state.tShift[current] < state.blkIndent) break;\n\n    // found end marker\n    if (state.src.slice(pos, max).trim().endsWith(\"$$\")) {\n      lastLine = state.src\n        .slice(pos, state.src.slice(0, max).lastIndexOf(\"$$\"))\n        .trim();\n      found = true;\n    }\n  }\n\n  state.line = found ? current + 1 : current;\n\n  const token = state.push(\"math_block\", \"math\", 0);\n\n  token.block = true;\n  token.content =\n    (firstLine ? `${firstLine}\\n` : \"\") +\n    state.getLines(start + 1, current, state.tShift[start], true) +\n    (lastLine ? `${lastLine}\\n` : \"\");\n  token.map = [start, state.line];\n  token.markup = \"$$\";\n\n  return true;\n};\n\nexport const tex: PluginWithOptions<MarkdownItTexOptions> = (md, options) => {\n  if (typeof options?.render !== \"function\")\n    throw new Error('[@mdit/plugin-tex]: \"render\" option should be a function');\n\n  const { allowInlineWithSpace = false, mathFence = false, render } = options;\n\n  // Handle ```math blocks\n  if (mathFence) {\n    const fence = md.renderer.rules.fence;\n\n    md.renderer.rules.fence = (...args): string => {\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n      const [tokens, index, , env] = args;\n      const { content, info } = tokens[index];\n\n      if (info.trim() === \"math\") return render(content, true, env);\n\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      return fence!(...args);\n    };\n  }\n\n  md.inline.ruler.after(\n    \"escape\",\n    \"math_inline\",\n    getInlineTex(allowInlineWithSpace),\n  );\n  md.block.ruler.after(\"blockquote\", \"math_block\", blockTex, {\n    alt: [\"paragraph\", \"reference\", \"blockquote\", \"list\"],\n  });\n\n  md.renderer.rules.math_inline = (tokens, index, _options, env): string =>\n    render(tokens[index].content, false, env);\n  md.renderer.rules.math_block = (tokens, index, _options, env): string =>\n    render(tokens[index].content, true, env);\n};\n"],"names":["isValidDelim","state","pos","allowInlineWithSpace","prevChar","nextChar","getInlineTex","silent","delimState","start","match","token","blockTex","end","max","firstLine","found","current","lastLine","tex","md","options","mathFence","render","fence","args","tokens","index","env","content","info","_options"],"mappings":"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"}
const f=(t,r,l)=>{const o=t.src.charAt(r-1),e=t.src.charAt(r+1);return{canOpen:l||e!==" "&&e!=="	",canClose:!/[0-9]/u.exec(e)&&(l||o!==" "&&o!=="	")}},h=t=>(r,l)=>{if(r.src[r.pos]!=="$")return!1;let o=f(r,r.pos,t);if(!o.canOpen)return l||(r.pending+="$"),r.pos++,!0;const e=r.pos+1;let s=e,n;for(;(s=r.src.indexOf("$",s))!==-1;){for(n=s-1;r.src[n]==="\\";)n--;if((s-n)%2===1)break;s++}if(s===-1)return l||(r.pending+="$"),r.pos=e,!0;if(s-e===0)return l||(r.pending+="$$"),r.pos=e+1,!0;if(o=f(r,s,t),!o.canClose)return l||(r.pending+="$"),r.pos=e,!0;if(!l){const c=r.push("math_inline","math",0);c.markup="$",c.content=r.src.slice(e,s)}return r.pos=s+1,!0},$=(t,r,l,o)=>{let e=t.bMarks[r]+t.tShift[r],s=t.eMarks[r];if(e+2>s||t.src.slice(e,e+2)!=="$$")return!1;e+=2;let n=t.src.slice(e,s).trim();if(o)return!0;let c=!1;n.endsWith("$$")&&(n=n.slice(0,-2),c=!0);let i=r,a="";for(;!c&&(i++,!(i>=l||(e=t.bMarks[i]+t.tShift[i],s=t.eMarks[i],e<s&&t.tShift[i]<t.blkIndent)));)t.src.slice(e,s).trim().endsWith("$$")&&(a=t.src.slice(e,t.src.slice(0,s).lastIndexOf("$$")).trim(),c=!0);t.line=c?i+1:i;const u=t.push("math_block","math",0);return u.block=!0,u.content=(n?`${n}
`:"")+t.getLines(r+1,i,t.tShift[r],!0)+(a?`${a}
`:""),u.map=[r,t.line],u.markup="$$",!0},m=(t,r)=>{if(typeof r?.render!="function")throw new Error('[@mdit/plugin-tex]: "render" option should be a function');const{allowInlineWithSpace:l=!1,mathFence:o=!1,render:e}=r;if(o){const s=t.renderer.rules.fence;t.renderer.rules.fence=(...n)=>{const[c,i,,a]=n,{content:u,info:p}=c[i];return p.trim()==="math"?e(u,!0,a):s(...n)}}t.inline.ruler.after("escape","math_inline",h(l)),t.block.ruler.after("blockquote","math_block",$,{alt:["paragraph","reference","blockquote","list"]}),t.renderer.rules.math_inline=(s,n,c,i)=>e(s[n].content,!1,i),t.renderer.rules.math_block=(s,n,c,i)=>e(s[n].content,!0,i)};export{m as tex};
//# sourceMappingURL=index.js.map

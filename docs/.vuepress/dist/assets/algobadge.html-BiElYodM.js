import{_ as l,e as o,j as r,f as i,g as a,h as t,i as n,r as m,o as d}from"./app-Da_MjU0J.js";const u={};function c(p,e){const s=m("RouteLink");return d(),o("div",null,[e[17]||(e[17]=r('<h1 id="algobadge" tabindex="-1"><a class="header-anchor" href="#algobadge"><span>Algobadge</span></a></h1><p><strong>work in progress!</strong> Qui puoi trovare hint per i problemi di Algobadge! Algobadge √® un raccolta di problemi divisi per argomento il cui completamento serve, ad esempio, per fare gli stage o partecipare alle nazionali. E&#39; un ottimo modo per esercitarsi negli argomenti imparati.</p><h2 id="intro" tabindex="-1"><a class="header-anchor" href="#intro"><span>Intro</span></a></h2><p>Tutti i problemi di categoria servono per allenarsi a scrivere in c++. Per questo non dovrebbero servire hint, se avete bug che non capite come risolvere chiedete pure a noi!</p><h2 id="lib" tabindex="-1"><a class="header-anchor" href="#lib"><span>Lib</span></a></h2><p>I problemi in questa categoria richiedono di conoscere l&#39;stl.</p><h3 id="cestini" tabindex="-1"><a class="header-anchor" href="#cestini"><span>Cestini</span></a></h3><details><summary>Hint:</summary><p>Usa un vettore di vettori.</p></details><h3 id="catalogo" tabindex="-1"><a class="header-anchor" href="#catalogo"><span>Catalogo</span></a></h3><details><summary>Hint 1:</summary><p>Vogliamo tenerci per ogni id il numero di libri con quell&#39;id.</p></details><details><summary>Hint 2:</summary><p>Usa una map.</p></details><h3 id="autogrill" tabindex="-1"><a class="header-anchor" href="#autogrill"><span>Autogrill</span></a></h3><details><summary>Hint 1:</summary><p>Vogliamo tenerci valori diversi tra loro e ci interessa vedere l&#39;elemento pi√π vicino ad un certo valore. Se solo ci fosse una struttura dati con una funzione simile....</p></details><details><summary>Hint 2:</summary><p>Usa un set con lower_bound (attento a come usare lower_bound).</p></details><h2 id="greedy" tabindex="-1"><a class="header-anchor" href="#greedy"><span>Greedy</span></a></h2>',15)),i("p",null,[e[1]||(e[1]=a("Tutti questi problemi si risolvono con tecniche greedy, quindi facendo scelte in modo avido, basandosi su un solo criterio. Potrebbe servire anche una ")),t(s,{to:"/materiale/binary_search.html"},{default:n(()=>e[0]||(e[0]=[a("binary search")])),_:1}),e[2]||(e[2]=a(" üòâ"))]),e[18]||(e[18]=r('<h3 id="collezionismo" tabindex="-1"><a class="header-anchor" href="#collezionismo"><span>Collezionismo</span></a></h3><details><summary>Hint 1:</summary><p>Intuitivamente come mettiamo i modellini sugli scaffali? Spoiler: in ordine crescente di C[i] (o decrescente).</p></details><details><summary>Hint 2:</summary><p>Se non ci fossero scaffali D sarebbe la somma delle differenze tra elementi consecutivi (se sono sortati).</p></details><details><summary>Hint 3:</summary><p>Aggiungendo uno scaffale come diminuisce la somma dei D[j]?</p></details><details><summary>Hint 4:</summary><p>Sorta le differenze tra elementi consecutivi.</p></details><h3 id="truffa" tabindex="-1"><a class="header-anchor" href="#truffa"><span>Truffa</span></a></h3><details><summary>Hint 1:</summary><p>Il criterio greedy dovrebbe essere chiaro, semplicemente sorto V.</p></details><details><summary>Hint 3:</summary><p>Se la complessit√† non torna, evita ad esempio di ricalcolare la somma o risortare ogni volta.</p></details><h3 id="quadri" tabindex="-1"><a class="header-anchor" href="#quadri"><span>Quadri</span></a></h3><details><summary>Hint 1:</summary><p>Calcolare B direttamente non √® cos√¨ facile. Per√≤ il fatto che ci chieda il B massimale e il fatto che i B che funzionano sono distribuiti in un modo ben preciso potrebbe darci un&#39;idea.</p></details><details><summary>Hint 2:</summary><p>Binary search su B</p></details><details><summary>Hint 3:</summary><p>Come facciamo a controllare che un certo B funzioni? Spoiler: sliding window</p></details><h2 id="rec" tabindex="-1"><a class="header-anchor" href="#rec"><span>Rec</span></a></h2><p>Questa categoria richiede di sapere cos&#39;√® la ricorsione e l&#39;induzione, cio√® risolvere un problema a partire da versioni pi√π piccole del problema stesso.</p><h3 id="antivirus" tabindex="-1"><a class="header-anchor" href="#antivirus"><span>Antivirus</span></a></h3><p>Non so cosa ci faccia questo problema in questa categoria.</p><details><summary>Hint 1:</summary><p>Le lunghezze delle stringhe sono tutte molto piccole, e abbiamo tanto tempo perch√© √® un problema terry quindi possiamo sostanzialmente fare qualsiasi cosa.</p></details><details><summary>Hint 2:</summary><p>Potrebbe essere utile usare sapere che esiste <a href="https://en.cppreference.com/w/cpp/string/basic_string/substr" target="_blank" rel="noopener noreferrer"><code>stringa.substr(inizio, lunghezza)</code></a> che ritorna una sottostringa e <a href="https://en.cppreference.com/w/cpp/string/basic_string/find" target="_blank" rel="noopener noreferrer"><code>stringa.find(sottostringa)</code></a> che trova l&#39;indice in cui si trova una sottostringa all&#39;interno di una stringa (se non c&#39;√® ritorna -1).</p></details><h3 id="ctf" tabindex="-1"><a class="header-anchor" href="#ctf"><span>Ctf</span></a></h3><details><summary>Hint 1:</summary><p>Prova a fare casi piccoli e trovare una formula.</p></details><details><summary>Hint 2:</summary><p><a href="https://en.wikipedia.org/wiki/Josephus_problem" target="_blank" rel="noopener noreferrer">https://en.wikipedia.org/wiki/Josephus_problem</a></p></details><h3 id="cabala" tabindex="-1"><a class="header-anchor" href="#cabala"><span>Cabala</span></a></h3><details><summary>Hint 1:</summary><p>N √® molto piccolo.</p></details><details><summary>Hint 2:</summary><p>Posso semplicemente controllare tutti i numeri dell cabala e trovare quello con il massimo resto modulo M.</p></details><details><summary>Hint 3:</summary><p>Per farlo usiamo il backtracking tenendoci il numero che abbiamo fino ad adesso e procedere per ricorsione aggiungendo 3, 6 o 9 controllando che sia diversa dalla scorsa cifra.</p></details><h2 id="math" tabindex="-1"><a class="header-anchor" href="#math"><span>Math</span></a></h2>',26)),i("p",null,[e[4]||(e[4]=a("Questa categoria richiede conoscenze generiche di matematica e ")),t(s,{to:"/materiale/fastexp.html"},{default:n(()=>e[3]||(e[3]=[a("fastexp")])),_:1}),e[5]||(e[5]=a("."))]),e[19]||(e[19]=r('<h3 id="caramelle" tabindex="-1"><a class="header-anchor" href="#caramelle"><span>Caramelle</span></a></h3><details><summary>Hint 1:</summary><p>La risposta √® semplicemente l&#39;mcm dei V[i].</p></details><details><summary>Hint 2:</summary><p>Si pu√≤ calcolare l&#39;mcm sapendo che mcm(a, b)*mcd(a, b) = a*b. Per calcolare l&#39;mcd si pu√≤ scrivere <a href="https://cp-algorithms.com/algebra/euclid-algorithm.html" target="_blank" rel="noopener noreferrer">l&#39;algoritmo di euclide</a> o usare <a href="https://en.cppreference.com/w/cpp/numeric/gcd" target="_blank" rel="noopener noreferrer"><code>gcd(a, b)</code></a>.</p></details><h3 id="rsa" tabindex="-1"><a class="header-anchor" href="#rsa"><span>Rsa</span></a></h3>',4)),i("details",null,[e[8]||(e[8]=i("summary",null,"Hint 1:",-1)),i("p",null,[e[7]||(e[7]=a("Il problema chiede sostanzialmente di calcolare velocemente delle potenze, e questo si pu√≤ fare con ")),t(s,{to:"/materiale/fastexp.html"},{default:n(()=>e[6]||(e[6]=[a("fastexp")])),_:1})])]),e[20]||(e[20]=r('<h3 id="scrigni" tabindex="-1"><a class="header-anchor" href="#scrigni"><span>Scrigni</span></a></h3><details><summary>Hint 1:</summary><p>Fai conti o fai casi piccoli e viene una formula chiusa. Se non sai come leggi i prossimi hint.</p></details><details><summary>Hint 2:</summary><p>Se ci sono $k$ scrigni tra cui scegliere qual&#39;√® la probabilit√† di beccare subito quello giusto?</p></details><details><summary>Hint 3:</summary><p>In media quante scosse prendo per indovinare il prossimo scrigno se ne ho gi√† indovinati $n-k$?</p></details><details><summary>Hint 4:</summary><p>Se non sei riuscito a fare il calcolo dell&#39;hint prima, prova a sommare per ogni $0 \\leq i\\leq k-1$ la probabilit√† di ricevere $i$ scosse per $i$.</p></details><details><summary>Hint 5:</summary><p>Dovrebbe venire qualcosa del genere: $\\frac{1}{k}\\cdot 0 + \\frac{k-1}{k}\\frac{1}{k-1}\\cdot 1 + \\frac{k-1}{k}\\frac{k-2}{k-1}\\frac{1}{k-2}\\cdot 2 \\dots = \\frac{0}{k} + \\frac{1}{k} + \\frac{2}{k} \\dots$</p></details><details><summary>Hint 6:</summary><p>Adesso se chiamiamo $f_k$ il numero medio di scosse avendo indovinato $n-k$ scrigni la risposta al problema sar√†: $f_n + f_{n-1} + \\dots + f_1$</p></details><details><summary>Hint 7:</summary><p>Se non ti √® chiaro come trasformare tutto questo in un&#39;unica formula chiusa ricordati che la somma dei numeri da 1 a $n$ √® $\\frac{n(n+1)}{2}$.</p></details><h2 id="grafi" tabindex="-1"><a class="header-anchor" href="#grafi"><span>Grafi</span></a></h2>',9)),i("p",null,[e[10]||(e[10]=a("Questa categoria richiede di conoscere ")),t(s,{to:"/materiale/grafi.html"},{default:n(()=>e[9]||(e[9]=[a("la teoria sui grafi")])),_:1}),e[11]||(e[11]=a(" e la ")),e[12]||(e[12]=i("a",{href:"https://cp-algorithms.com/data_structures/disjoint_set_union.html",target:"_blank",rel:"noopener noreferrer"},"dsu",-1)),e[13]||(e[13]=a("."))]),e[21]||(e[21]=r('<h3 id="interruttori" tabindex="-1"><a class="header-anchor" href="#interruttori"><span>Interruttori</span></a></h3><details><summary>Hint 1</summary><p>Per riuscire a spegnere tutte le lampadine √® necessario arrivare a un interruttore di tipo 1, quindi...</p></details><details><summary>Hint 2</summary><p>...quindi vogliamo trovare il nodo che massimizza il minimo delle distanze da un interruttore di tipo 1.</p></details><details><summary>Hint 3</summary><p>Visto che il grafo non √® pesato basta fare una BFS a pi√π sorgenti partendo dalle lampadine spente dagli interruttori di tipo 1 e vedere la lampadina con distanza maggiore. (per fare una bfs a pi√π sorgenti basta aggiungere alla queue tutti i nodi da cui vogliamo partire e eseguire il classico algoritmo)</p></details><h3 id="connessioni" tabindex="-1"><a class="header-anchor" href="#connessioni"><span>Connessioni</span></a></h3><details><summary>Hint 1:</summary><p>Implementa una <a href="https://cp-algorithms.com/data_structures/disjoint_set_union.html" target="_blank" rel="noopener noreferrer">dsu</a></p></details><h3 id="mincammino2" tabindex="-1"><a class="header-anchor" href="#mincammino2"><span>Mincammino2</span></a></h3>',7)),i("details",null,[e[16]||(e[16]=i("summary",null,"Hint 1:",-1)),i("p",null,[e[15]||(e[15]=a("Implementa ")),t(s,{to:"/materiale/grafi.html#dijkstra"},{default:n(()=>e[14]||(e[14]=[a("dijkstra")])),_:1})])]),e[22]||(e[22]=r('<h2 id="ds" tabindex="-1"><a class="header-anchor" href="#ds"><span>Ds</span></a></h2><p>Questa categoria richiede di conoscere il concetto di prefix sum e strutture dati come il segment tree.</p><h3 id="calcio" tabindex="-1"><a class="header-anchor" href="#calcio"><span>Calcio</span></a></h3><details><summary>Hint 1:</summary><p>Posso provare tutti i possibili campi da calcio.</p></details><details><summary>Hint 2:</summary><p>ISe solo potessi generalizzare la prefix sum a pi√π dimensioni...</p></details><details><summary>Hint 3:</summary><p>Usa una <a href="https://usaco.guide/silver/more-prefix-sums?lang=cpp#2d-prefix-sums" target="_blank" rel="noopener noreferrer">prefix sum 2d</a>.</p></details><h3 id="museo" tabindex="-1"><a class="header-anchor" href="#museo"><span>Museo</span></a></h3><details><summary>Hint 1:</summary><p>Implementa un segment tree.</p></details><h3 id="paletta" tabindex="-1"><a class="header-anchor" href="#paletta"><span>Paletta</span></a></h3><details><summary>Hint 1:</summary><p>Come faccio a controllare se posso sortare una data lista?</p></details><details><summary>Hint 2:</summary><p>Forse la parit√† degli indici si comporta in modo interessante...</p></details><details><summary>Hint 3:</summary><p>Come faccio a contare il numero di passaggi richiesti?</p></details><details><summary>Hint 4:</summary><p>Il problema si riconduce a contare il numero di inversioni in un array. Posso farlo con un segment tree?</p></details>',13))])}const g=l(u,[["render",c],["__file","algobadge.html.vue"]]),f=JSON.parse('{"path":"/algobadge.html","title":"Algobadge","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"Intro","slug":"intro","link":"#intro","children":[]},{"level":2,"title":"Lib","slug":"lib","link":"#lib","children":[{"level":3,"title":"Cestini","slug":"cestini","link":"#cestini","children":[]},{"level":3,"title":"Catalogo","slug":"catalogo","link":"#catalogo","children":[]},{"level":3,"title":"Autogrill","slug":"autogrill","link":"#autogrill","children":[]}]},{"level":2,"title":"Greedy","slug":"greedy","link":"#greedy","children":[{"level":3,"title":"Collezionismo","slug":"collezionismo","link":"#collezionismo","children":[]},{"level":3,"title":"Truffa","slug":"truffa","link":"#truffa","children":[]},{"level":3,"title":"Quadri","slug":"quadri","link":"#quadri","children":[]}]},{"level":2,"title":"Rec","slug":"rec","link":"#rec","children":[{"level":3,"title":"Antivirus","slug":"antivirus","link":"#antivirus","children":[]},{"level":3,"title":"Ctf","slug":"ctf","link":"#ctf","children":[]},{"level":3,"title":"Cabala","slug":"cabala","link":"#cabala","children":[]}]},{"level":2,"title":"Math","slug":"math","link":"#math","children":[{"level":3,"title":"Caramelle","slug":"caramelle","link":"#caramelle","children":[]},{"level":3,"title":"Rsa","slug":"rsa","link":"#rsa","children":[]},{"level":3,"title":"Scrigni","slug":"scrigni","link":"#scrigni","children":[]}]},{"level":2,"title":"Grafi","slug":"grafi","link":"#grafi","children":[{"level":3,"title":"Interruttori","slug":"interruttori","link":"#interruttori","children":[]},{"level":3,"title":"Connessioni","slug":"connessioni","link":"#connessioni","children":[]},{"level":3,"title":"Mincammino2","slug":"mincammino2","link":"#mincammino2","children":[]}]},{"level":2,"title":"Ds","slug":"ds","link":"#ds","children":[{"level":3,"title":"Calcio","slug":"calcio","link":"#calcio","children":[]},{"level":3,"title":"Museo","slug":"museo","link":"#museo","children":[]},{"level":3,"title":"Paletta","slug":"paletta","link":"#paletta","children":[]}]}],"git":{"updatedTime":1749482897000,"contributors":[{"name":"nik-din","username":"nik-din","email":"nik.dindo@gmail.com","commits":12,"url":"https://github.com/nik-din"},{"name":"Giovanni","username":"Giovanni","email":"112493877+ciao-gio@users.noreply.github.com","commits":1,"url":"https://github.com/Giovanni"}]},"filePathRelative":"algobadge.md"}');export{g as comp,f as data};
